diff -rup -x config.h valgrind-3.8.1/VEX/priv/guest_arm_toIR.c valgrind-3.8.1-static/VEX/priv/guest_arm_toIR.c
--- valgrind-3.8.1/VEX/priv/guest_arm_toIR.c	2012-09-17 10:57:37.000000000 -0700
+++ valgrind-3.8.1-static/VEX/priv/guest_arm_toIR.c	2013-11-08 23:03:02.557888339 -0800
@@ -187,23 +187,41 @@ static IRTemp r15kind;
 
 /* Do a little-endian load of a 32-bit word, regardless of the
    endianness of the underlying host. */
-static inline UInt getUIntLittleEndianly ( UChar* p )
+static inline UInt getUInt( UChar* p )
 {
    UInt w = 0;
-   w = (w << 8) | p[3];
-   w = (w << 8) | p[2];
-   w = (w << 8) | p[1];
-   w = (w << 8) | p[0];
+   if (host_is_bigendian)
+   {
+   	w = (w << 8) | p[0];
+   	w = (w << 8) | p[1];
+   	w = (w << 8) | p[2];
+   	w = (w << 8) | p[3];
+   }
+   else
+   {
+   	w = (w << 8) | p[3];
+   	w = (w << 8) | p[2];
+   	w = (w << 8) | p[1];
+   	w = (w << 8) | p[0];
+   }
    return w;
 }
 
 /* Do a little-endian load of a 16-bit word, regardless of the
    endianness of the underlying host. */
-static inline UShort getUShortLittleEndianly ( UChar* p )
+static inline UShort getUShort( UChar* p )
 {
    UShort w = 0;
-   w = (w << 8) | p[1];
-   w = (w << 8) | p[0];
+   if (host_is_bigendian)
+   {
+   	w = (w << 8) | p[0];
+   	w = (w << 8) | p[1];
+   }
+   else
+   {
+   	w = (w << 8) | p[1];
+   	w = (w << 8) | p[0];
+   }
    return w;
 }
 
@@ -12598,7 +12616,7 @@ DisResult disInstr_ARM_WRK (
    /* At least this is simple on ARM: insns are all 4 bytes long, and
       4-aligned.  So just fish the whole thing out of memory right now
       and have done. */
-   insn = getUIntLittleEndianly( guest_instr );
+   insn = getUInt( guest_instr );
 
    if (0) vex_printf("insn: 0x%x\n", insn);
 
@@ -12622,12 +12640,12 @@ DisResult disInstr_ARM_WRK (
       UInt word2 = 0xE1A0C6EC;
       UInt word3 = 0xE1A0CEEC;
       UInt word4 = 0xE1A0C9EC;
-      if (getUIntLittleEndianly(code+ 0) == word1 &&
-          getUIntLittleEndianly(code+ 4) == word2 &&
-          getUIntLittleEndianly(code+ 8) == word3 &&
-          getUIntLittleEndianly(code+12) == word4) {
+      if (getUInt(code+ 0) == word1 &&
+          getUInt(code+ 4) == word2 &&
+          getUInt(code+ 8) == word3 &&
+          getUInt(code+12) == word4) {
          /* Got a "Special" instruction preamble.  Which one is it? */
-         if (getUIntLittleEndianly(code+16) == 0xE18AA00A
+         if (getUInt(code+16) == 0xE18AA00A
                                                /* orr r10,r10,r10 */) {
             /* R3 = client_request ( R4 ) */
             DIP("r3 = client_request ( %%r4 )\n");
@@ -12637,7 +12655,7 @@ DisResult disInstr_ARM_WRK (
             goto decode_success;
          }
          else
-         if (getUIntLittleEndianly(code+16) == 0xE18BB00B
+         if (getUInt(code+16) == 0xE18BB00B
                                                /* orr r11,r11,r11 */) {
             /* R3 = guest_NRADDR */
             DIP("r3 = guest_NRADDR\n");
@@ -12646,7 +12664,7 @@ DisResult disInstr_ARM_WRK (
             goto decode_success;
          }
          else
-         if (getUIntLittleEndianly(code+16) == 0xE18CC00C
+         if (getUInt(code+16) == 0xE18CC00C
                                                /* orr r12,r12,r12 */) {
             /*  branch-and-link-to-noredir R4 */
             DIP("branch-and-link-to-noredir r4\n");
@@ -12658,7 +12676,7 @@ DisResult disInstr_ARM_WRK (
          }
          /* We don't know what it is.  Set opc1/opc2 so decode_failure
             can print the insn following the Special-insn preamble. */
-         insn = getUIntLittleEndianly(code+16);
+         insn = getUInt(code+16);
          goto decode_failure;
          /*NOTREACHED*/
       }
@@ -14801,7 +14819,7 @@ DisResult disInstr_THUMB_WRK (
       get them both out immediately because it risks a fault (very
       unlikely, but ..) if the second 16 bits aren't actually
       necessary. */
-   insn0 = getUShortLittleEndianly( guest_instr );
+   insn0 = getUShort( guest_instr );
    insn1 = 0; /* We'll get it later, once we know we need it. */
 
    /* Similarly, will set this later. */
@@ -14828,13 +14846,13 @@ DisResult disInstr_THUMB_WRK (
       UInt word2 = 0x3C7CEA4F;
       UInt word3 = 0x7C7CEA4F;
       UInt word4 = 0x4CFCEA4F;
-      if (getUIntLittleEndianly(code+ 0) == word1 &&
-          getUIntLittleEndianly(code+ 4) == word2 &&
-          getUIntLittleEndianly(code+ 8) == word3 &&
-          getUIntLittleEndianly(code+12) == word4) {
+      if (getUInt(code+ 0) == word1 &&
+          getUInt(code+ 4) == word2 &&
+          getUInt(code+ 8) == word3 &&
+          getUInt(code+12) == word4) {
          /* Got a "Special" instruction preamble.  Which one is it? */
          // 0x 0A 0A EA 4A
-         if (getUIntLittleEndianly(code+16) == 0x0A0AEA4A
+         if (getUInt(code+16) == 0x0A0AEA4A
                                                /* orr.w r10,r10,r10 */) {
             /* R3 = client_request ( R4 ) */
             DIP("r3 = client_request ( %%r4 )\n");
@@ -14845,7 +14863,7 @@ DisResult disInstr_THUMB_WRK (
          }
          else
          // 0x 0B 0B EA 4B
-         if (getUIntLittleEndianly(code+16) == 0x0B0BEA4B
+         if (getUInt(code+16) == 0x0B0BEA4B
                                                /* orr r11,r11,r11 */) {
             /* R3 = guest_NRADDR */
             DIP("r3 = guest_NRADDR\n");
@@ -14855,7 +14873,7 @@ DisResult disInstr_THUMB_WRK (
          }
          else
          // 0x 0C 0C EA 4C
-         if (getUIntLittleEndianly(code+16) == 0x0C0CEA4C
+         if (getUInt(code+16) == 0x0C0CEA4C
                                                /* orr r12,r12,r12 */) {
             /*  branch-and-link-to-noredir R4 */
             DIP("branch-and-link-to-noredir r4\n");
@@ -14867,7 +14885,7 @@ DisResult disInstr_THUMB_WRK (
          }
          /* We don't know what it is.  Set insn0 so decode_failure
             can print the insn following the Special-insn preamble. */
-         insn0 = getUShortLittleEndianly(code+16);
+         insn0 = getUShort(code+16);
          goto decode_failure;
          /*NOTREACHED*/
       }
@@ -16478,7 +16496,7 @@ DisResult disInstr_THUMB_WRK (
 
    /* second 16 bits of the instruction, if any */
    vassert(insn1 == 0);
-   insn1 = getUShortLittleEndianly( guest_instr+2 );
+   insn1 = getUShort( guest_instr+2 );
 
    anOp   = Iop_INVALID; /* paranoia */
    anOpNm = NULL;        /* paranoia */
diff -rup -x config.h valgrind-3.8.1/VEX/priv/guest_mips_toIR.c valgrind-3.8.1-static/VEX/priv/guest_mips_toIR.c
--- valgrind-3.8.1/VEX/priv/guest_mips_toIR.c	2012-08-17 00:00:00.000000000 -0700
+++ valgrind-3.8.1-static/VEX/priv/guest_mips_toIR.c	2013-11-08 22:55:17.501876627 -0800
@@ -30,6 +30,12 @@
 
 /* Translates MIPS code to IR. */
 
+#ifndef _MIPSEB
+#ifndef _MIPSEL
+#define _MIPSEB
+#endif
+#endif
+
 #include "libvex_basictypes.h"
 #include "libvex_ir.h"
 #include "libvex.h"
diff -rup -x config.h valgrind-3.8.1/VEX/priv/main_main.c valgrind-3.8.1-static/VEX/priv/main_main.c
--- valgrind-3.8.1/VEX/priv/main_main.c	2012-08-17 00:00:00.000000000 -0700
+++ valgrind-3.8.1-static/VEX/priv/main_main.c	2013-11-08 23:04:02.657889852 -0800
@@ -33,6 +33,12 @@
    without prior written permission.
 */
 
+#ifndef VKI_BIG_ENDIAN
+#ifndef VKI_LITTLE_ENDIAN
+#define VKI_BIG_ENDIAN
+#endif
+#endif
+
 #include "libvex.h"
 #include "libvex_emwarn.h"
 #include "libvex_guest_x86.h"
@@ -393,7 +399,11 @@ VexTranslateResult LibVEX_Translate ( Ve
          emit        = (Int(*)(Bool*,UChar*,Int,HInstr*,Bool,
                                void*,void*,void*,void*))
                        emit_ARMInstr;
+#if defined(VKI_BIG_ENDIAN)
+         host_is_bigendian = True;
+#else
          host_is_bigendian = False;
+#endif
          host_word_type    = Ity_I32;
          vassert(are_valid_hwcaps(VexArchARM, vta->archinfo_host.hwcaps));
          break;
@@ -749,115 +759,115 @@ VexTranslateResult LibVEX_Translate ( Ve
                    " Instruction selection "
                    "------------------------\n");
 
-   /* No guest has its IP field at offset zero.  If this fails it
-      means some transformation pass somewhere failed to update/copy
-      irsb->offsIP properly. */
-   vassert(irsb->offsIP >= 16);
-
-   vcode = iselSB ( irsb, vta->arch_host,
-                    &vta->archinfo_host, 
-                    &vta->abiinfo_both,
-                    offB_HOST_EvC_COUNTER,
-                    offB_HOST_EvC_FAILADDR,
-                    chainingAllowed,
-                    vta->addProfInc,
-                    max_ga );
+   // COMMENTED OUT FOR PYVEX_STATIC: /* No guest has its IP field at offset zero.  If this fails it
+   // COMMENTED OUT FOR PYVEX_STATIC:    means some transformation pass somewhere failed to update/copy
+   // COMMENTED OUT FOR PYVEX_STATIC:    irsb->offsIP properly. */
+   // COMMENTED OUT FOR PYVEX_STATIC: vassert(irsb->offsIP >= 16);
+
+   // COMMENTED OUT FOR PYVEX_STATIC: vcode = iselSB ( irsb, vta->arch_host,
+   // COMMENTED OUT FOR PYVEX_STATIC:                  &vta->archinfo_host, 
+   // COMMENTED OUT FOR PYVEX_STATIC:                  &vta->abiinfo_both,
+   // COMMENTED OUT FOR PYVEX_STATIC:                  offB_HOST_EvC_COUNTER,
+   // COMMENTED OUT FOR PYVEX_STATIC:                  offB_HOST_EvC_FAILADDR,
+   // COMMENTED OUT FOR PYVEX_STATIC:                  chainingAllowed,
+   // COMMENTED OUT FOR PYVEX_STATIC:                  vta->addProfInc,
+   // COMMENTED OUT FOR PYVEX_STATIC:                  max_ga );
+
+   // COMMENTED OUT FOR PYVEX_STATIC: vexAllocSanityCheck();
+
+   // COMMENTED OUT FOR PYVEX_STATIC: if (vex_traceflags & VEX_TRACE_VCODE)
+   // COMMENTED OUT FOR PYVEX_STATIC:    vex_printf("\n");
+
+   // COMMENTED OUT FOR PYVEX_STATIC: if (vex_traceflags & VEX_TRACE_VCODE) {
+   // COMMENTED OUT FOR PYVEX_STATIC:    for (i = 0; i < vcode->arr_used; i++) {
+   // COMMENTED OUT FOR PYVEX_STATIC:       vex_printf("%3d   ", i);
+   // COMMENTED OUT FOR PYVEX_STATIC:       ppInstr(vcode->arr[i], mode64);
+   // COMMENTED OUT FOR PYVEX_STATIC:       vex_printf("\n");
+   // COMMENTED OUT FOR PYVEX_STATIC:    }
+   // COMMENTED OUT FOR PYVEX_STATIC:    vex_printf("\n");
+   // COMMENTED OUT FOR PYVEX_STATIC: }
+
+   // COMMENTED OUT FOR PYVEX_STATIC: /* Register allocate. */
+   // COMMENTED OUT FOR PYVEX_STATIC: rcode = doRegisterAllocation ( vcode, available_real_regs,
+   // COMMENTED OUT FOR PYVEX_STATIC:                                n_available_real_regs,
+   // COMMENTED OUT FOR PYVEX_STATIC:                                isMove, getRegUsage, mapRegs, 
+   // COMMENTED OUT FOR PYVEX_STATIC:                                genSpill, genReload, directReload, 
+   // COMMENTED OUT FOR PYVEX_STATIC:                                guest_sizeB,
+   // COMMENTED OUT FOR PYVEX_STATIC:                                ppInstr, ppReg, mode64 );
+
+   // COMMENTED OUT FOR PYVEX_STATIC: vexAllocSanityCheck();
+
+   // COMMENTED OUT FOR PYVEX_STATIC: if (vex_traceflags & VEX_TRACE_RCODE) {
+   // COMMENTED OUT FOR PYVEX_STATIC:    vex_printf("\n------------------------" 
+   // COMMENTED OUT FOR PYVEX_STATIC:                 " Register-allocated code "
+   // COMMENTED OUT FOR PYVEX_STATIC:                 "------------------------\n\n");
+   // COMMENTED OUT FOR PYVEX_STATIC:    for (i = 0; i < rcode->arr_used; i++) {
+   // COMMENTED OUT FOR PYVEX_STATIC:       vex_printf("%3d   ", i);
+   // COMMENTED OUT FOR PYVEX_STATIC:       ppInstr(rcode->arr[i], mode64);
+   // COMMENTED OUT FOR PYVEX_STATIC:       vex_printf("\n");
+   // COMMENTED OUT FOR PYVEX_STATIC:    }
+   // COMMENTED OUT FOR PYVEX_STATIC:    vex_printf("\n");
+   // COMMENTED OUT FOR PYVEX_STATIC: }
+
+   // COMMENTED OUT FOR PYVEX_STATIC: /* HACK */
+   // COMMENTED OUT FOR PYVEX_STATIC: if (0) { 
+   // COMMENTED OUT FOR PYVEX_STATIC:    *(vta->host_bytes_used) = 0;
+   // COMMENTED OUT FOR PYVEX_STATIC:    res.status = VexTransOK; return res;
+   // COMMENTED OUT FOR PYVEX_STATIC: }
+   // COMMENTED OUT FOR PYVEX_STATIC: /* end HACK */
+
+   // COMMENTED OUT FOR PYVEX_STATIC: /* Assemble */
+   // COMMENTED OUT FOR PYVEX_STATIC: if (vex_traceflags & VEX_TRACE_ASM) {
+   // COMMENTED OUT FOR PYVEX_STATIC:    vex_printf("\n------------------------" 
+   // COMMENTED OUT FOR PYVEX_STATIC:                 " Assembly "
+   // COMMENTED OUT FOR PYVEX_STATIC:                 "------------------------\n\n");
+   // COMMENTED OUT FOR PYVEX_STATIC: }
+
+   // COMMENTED OUT FOR PYVEX_STATIC: out_used = 0; /* tracks along the host_bytes array */
+   // COMMENTED OUT FOR PYVEX_STATIC: for (i = 0; i < rcode->arr_used; i++) {
+   // COMMENTED OUT FOR PYVEX_STATIC:    HInstr* hi           = rcode->arr[i];
+   // COMMENTED OUT FOR PYVEX_STATIC:    Bool    hi_isProfInc = False;
+   // COMMENTED OUT FOR PYVEX_STATIC:    if (UNLIKELY(vex_traceflags & VEX_TRACE_ASM)) {
+   // COMMENTED OUT FOR PYVEX_STATIC:       ppInstr(hi, mode64);
+   // COMMENTED OUT FOR PYVEX_STATIC:       vex_printf("\n");
+   // COMMENTED OUT FOR PYVEX_STATIC:    }
+   // COMMENTED OUT FOR PYVEX_STATIC:    j = emit( &hi_isProfInc,
+   // COMMENTED OUT FOR PYVEX_STATIC:              insn_bytes, sizeof insn_bytes, hi, mode64,
+   // COMMENTED OUT FOR PYVEX_STATIC:              vta->disp_cp_chain_me_to_slowEP,
+   // COMMENTED OUT FOR PYVEX_STATIC:              vta->disp_cp_chain_me_to_fastEP,
+   // COMMENTED OUT FOR PYVEX_STATIC:              vta->disp_cp_xindir,
+   // COMMENTED OUT FOR PYVEX_STATIC:              vta->disp_cp_xassisted );
+   // COMMENTED OUT FOR PYVEX_STATIC:    if (UNLIKELY(vex_traceflags & VEX_TRACE_ASM)) {
+   // COMMENTED OUT FOR PYVEX_STATIC:       for (k = 0; k < j; k++)
+   // COMMENTED OUT FOR PYVEX_STATIC:          if (insn_bytes[k] < 16)
+   // COMMENTED OUT FOR PYVEX_STATIC:             vex_printf("0%x ",  (UInt)insn_bytes[k]);
+   // COMMENTED OUT FOR PYVEX_STATIC:          else
+   // COMMENTED OUT FOR PYVEX_STATIC:             vex_printf("%x ", (UInt)insn_bytes[k]);
+   // COMMENTED OUT FOR PYVEX_STATIC:       vex_printf("\n\n");
+   // COMMENTED OUT FOR PYVEX_STATIC:    }
+   // COMMENTED OUT FOR PYVEX_STATIC:    if (UNLIKELY(out_used + j > vta->host_bytes_size)) {
+   // COMMENTED OUT FOR PYVEX_STATIC:       vexSetAllocModeTEMP_and_clear();
+   // COMMENTED OUT FOR PYVEX_STATIC:       vex_traceflags = 0;
+   // COMMENTED OUT FOR PYVEX_STATIC:       res.status = VexTransOutputFull;
+   // COMMENTED OUT FOR PYVEX_STATIC:       return res;
+   // COMMENTED OUT FOR PYVEX_STATIC:    }
+   // COMMENTED OUT FOR PYVEX_STATIC:    if (UNLIKELY(hi_isProfInc)) {
+   // COMMENTED OUT FOR PYVEX_STATIC:       vassert(vta->addProfInc); /* else where did it come from? */
+   // COMMENTED OUT FOR PYVEX_STATIC:       vassert(res.offs_profInc == -1); /* there can be only one (tm) */
+   // COMMENTED OUT FOR PYVEX_STATIC:       vassert(out_used >= 0);
+   // COMMENTED OUT FOR PYVEX_STATIC:       res.offs_profInc = out_used;
+   // COMMENTED OUT FOR PYVEX_STATIC:    }
+   // COMMENTED OUT FOR PYVEX_STATIC:    { UChar* dst = &vta->host_bytes[out_used];
+   // COMMENTED OUT FOR PYVEX_STATIC:      for (k = 0; k < j; k++) {
+   // COMMENTED OUT FOR PYVEX_STATIC:         dst[k] = insn_bytes[k];
+   // COMMENTED OUT FOR PYVEX_STATIC:      }
+   // COMMENTED OUT FOR PYVEX_STATIC:      out_used += j;
+   // COMMENTED OUT FOR PYVEX_STATIC:    }
+   // COMMENTED OUT FOR PYVEX_STATIC:    vassert(out_used <= vta->host_bytes_size);
+   // COMMENTED OUT FOR PYVEX_STATIC: }
+   // COMMENTED OUT FOR PYVEX_STATIC: *(vta->host_bytes_used) = out_used;
 
-   vexAllocSanityCheck();
-
-   if (vex_traceflags & VEX_TRACE_VCODE)
-      vex_printf("\n");
-
-   if (vex_traceflags & VEX_TRACE_VCODE) {
-      for (i = 0; i < vcode->arr_used; i++) {
-         vex_printf("%3d   ", i);
-         ppInstr(vcode->arr[i], mode64);
-         vex_printf("\n");
-      }
-      vex_printf("\n");
-   }
-
-   /* Register allocate. */
-   rcode = doRegisterAllocation ( vcode, available_real_regs,
-                                  n_available_real_regs,
-                                  isMove, getRegUsage, mapRegs, 
-                                  genSpill, genReload, directReload, 
-                                  guest_sizeB,
-                                  ppInstr, ppReg, mode64 );
-
-   vexAllocSanityCheck();
-
-   if (vex_traceflags & VEX_TRACE_RCODE) {
-      vex_printf("\n------------------------" 
-                   " Register-allocated code "
-                   "------------------------\n\n");
-      for (i = 0; i < rcode->arr_used; i++) {
-         vex_printf("%3d   ", i);
-         ppInstr(rcode->arr[i], mode64);
-         vex_printf("\n");
-      }
-      vex_printf("\n");
-   }
-
-   /* HACK */
-   if (0) { 
-      *(vta->host_bytes_used) = 0;
-      res.status = VexTransOK; return res;
-   }
-   /* end HACK */
-
-   /* Assemble */
-   if (vex_traceflags & VEX_TRACE_ASM) {
-      vex_printf("\n------------------------" 
-                   " Assembly "
-                   "------------------------\n\n");
-   }
-
-   out_used = 0; /* tracks along the host_bytes array */
-   for (i = 0; i < rcode->arr_used; i++) {
-      HInstr* hi           = rcode->arr[i];
-      Bool    hi_isProfInc = False;
-      if (UNLIKELY(vex_traceflags & VEX_TRACE_ASM)) {
-         ppInstr(hi, mode64);
-         vex_printf("\n");
-      }
-      j = emit( &hi_isProfInc,
-                insn_bytes, sizeof insn_bytes, hi, mode64,
-                vta->disp_cp_chain_me_to_slowEP,
-                vta->disp_cp_chain_me_to_fastEP,
-                vta->disp_cp_xindir,
-                vta->disp_cp_xassisted );
-      if (UNLIKELY(vex_traceflags & VEX_TRACE_ASM)) {
-         for (k = 0; k < j; k++)
-            if (insn_bytes[k] < 16)
-               vex_printf("0%x ",  (UInt)insn_bytes[k]);
-            else
-               vex_printf("%x ", (UInt)insn_bytes[k]);
-         vex_printf("\n\n");
-      }
-      if (UNLIKELY(out_used + j > vta->host_bytes_size)) {
-         vexSetAllocModeTEMP_and_clear();
-         vex_traceflags = 0;
-         res.status = VexTransOutputFull;
-         return res;
-      }
-      if (UNLIKELY(hi_isProfInc)) {
-         vassert(vta->addProfInc); /* else where did it come from? */
-         vassert(res.offs_profInc == -1); /* there can be only one (tm) */
-         vassert(out_used >= 0);
-         res.offs_profInc = out_used;
-      }
-      { UChar* dst = &vta->host_bytes[out_used];
-        for (k = 0; k < j; k++) {
-           dst[k] = insn_bytes[k];
-        }
-        out_used += j;
-      }
-      vassert(out_used <= vta->host_bytes_size);
-   }
-   *(vta->host_bytes_used) = out_used;
-
-   vexAllocSanityCheck();
+   // COMMENTED OUT FOR PYVEX_STATIC: vexAllocSanityCheck();
 
    vexSetAllocModeTEMP_and_clear();
 
